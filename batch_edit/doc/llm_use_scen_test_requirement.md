# batch_edit.sh LLM使用场景测试需求文档

## 1. 文档概述

### 1.1 目的
本文档定义了针对batch_edit.sh工具的LLM使用场景测试需求。该工具专门为Claude Code及其背后的LLM设计，旨在通过单次工具调用替代多次编辑操作，从而显著提升令牌效率和执行速度。

### 1.2 背景
- **性能瓶颈**: LLM进行文件编辑时，每次Edit/Write操作都需要独立的API调用
- **延迟问题**: 网络往返、安全验证、状态管理造成的累积延迟
- **解决方案**: 通过batch_edit.sh将多个操作合并为单次执行，减少工具调用开销

### 1.3 测试范围
本测试涵盖LLM在实际代码开发、重构、文档生成等场景中使用batch_edit.sh的典型模式。

## 2. LLM使用模式分析

### 2.1 核心使用特征
- **绝对行号依赖**: LLM读取文件时获得带行号的内容，基于精确行号生成操作
- **批量操作**: 一次性处理多个文件的多种操作类型
- **原子性要求**: 所有操作必须全部成功或全部失败
- **JSON结构生成**: LLM生成复杂嵌套的JSON操作描述

### 2.2 典型工作流程
1. **读取分析阶段**: 使用Read工具读取文件，获得带行号内容
2. **操作规划阶段**: 基于文件内容分析，确定需要修改的具体行号
3. **JSON生成阶段**: 生成包含多个操作的JSON描述文件
4. **批量执行阶段**: 调用batch_edit.sh执行所有操作

## 3. 测试分类与场景

### 3.1 基础LLM使用场景 (12_test_llm_scenarios.sh)

#### 3.1.1 复杂JSON生成测试
- **目标**: 验证LLM生成的复杂JSON结构能被正确解析和执行
- **场景**:
  - 包含20+操作的大型JSON
  - 深层嵌套的操作描述
  - 混合操作类型：create→replace→insert→delete→patch
  - 包含特殊字符的内容：引号、反斜杠、换行符

#### 3.1.2 行号精确性测试
- **目标**: 验证基于绝对行号的操作准确性
- **场景**:
  - 读取文件后基于具体行号进行replace操作
  - 在指定行号insert新内容
  - delete特定行号范围
  - 多个操作引用同一文件的不同行号

#### 3.1.3 内容处理测试
- **目标**: 验证各种内容类型的正确处理
- **场景**:
  - 空内容替换和插入
  - 大块多行内容(数百行)
  - 包含代码语法的内容(函数、类、注释)
  - 包含JSON、XML、Markdown等结构化内容

### 3.2 代码重构场景 (13_test_llm_code_refactoring.sh)

#### 3.2.1 函数提取重构
- **目标**: 模拟LLM执行"提取函数"重构操作
- **场景**:
  - 从原文件delete指定行范围
  - create新文件
  - insert提取的代码到新文件
  - 在原位置insert函数调用

#### 3.2.2 方法签名更新
- **目标**: 跨文件更新方法签名
- **场景**:
  - 替换函数定义中的参数列表
  - 更新所有调用点的参数传递
  - 更新相关文档中的示例

#### 3.2.3 导入管理
- **目标**: 整理和更新import语句
- **场景**:
  - 在文件开头insert新的import
  - replace现有import路径
  - delete未使用的import
  - 按字母顺序重新组织import

#### 3.2.4 类结构调整
- **目标**: 重组类的内部结构
- **场景**:
  - 移动方法到不同位置(delete+insert)
  - 添加新的属性和方法
  - 更新构造函数
  - 调整访问修饰符

### 3.3 多文件项目编辑 (14_test_llm_multi_file_edits.sh)

#### 3.3.1 跨文件依赖更新
- **目标**: 更新文件间的依赖关系
- **场景**:
  - 移动文件时更新import路径
  - 重命名模块时更新所有引用
  - 添加新依赖时批量更新

#### 3.3.2 API变更传播
- **目标**: API更改后的批量更新
- **场景**:
  - 函数签名变更后更新10+个调用文件
  - 接口定义变更后更新实现类
  - 数据结构变更后更新相关处理代码

#### 3.3.3 配置同步
- **目标**: 多环境配置文件的原子性更新
- **场景**:
  - 同时更新开发、测试、生产配置
  - 基于模板生成环境特定配置
  - 配置项的批量添加或移除

#### 3.3.4 测试套件生成
- **目标**: 基于源码自动生成测试
- **场景**:
  - 分析源文件结构
  - create对应的测试文件
  - insert测试用例模板
  - 生成mock和fixture文件

#### 3.3.5 大规模并行修改
- **目标**: 验证大量文件的并行处理能力
- **场景**:
  - 50+操作跨越20+文件
  - 复杂的操作执行顺序
  - 文件间的依赖关系处理

### 3.4 错误恢复与边缘情况 (15_test_llm_error_recovery.sh)

#### 3.4.1 JSON格式错误处理
- **目标**: 验证对格式错误JSON的处理
- **场景**:
  - 语法错误的JSON
  - 缺失必要字段
  - 类型错误的字段值
  - 不完整的操作描述

#### 3.4.2 行号计算错误
- **目标**: 处理行号引用错误
- **场景**:
  - 超出文件范围的行号
  - 负数行号
  - start_line > end_line的情况
  - 基于过时文件内容的行号

#### 3.4.3 冲突操作检测
- **目标**: 验证操作冲突的检测和处理
- **场景**:
  - 重叠行范围的操作
  - 同一位置的多个insert
  - delete后再对已删除行进行操作
  - 复杂的多文件冲突场景

#### 3.4.4 回滚验证
- **目标**: 确保失败后的完美恢复
- **场景**:
  - 操作失败后所有文件恢复原状
  - 部分创建的文件被正确清理
  - backup机制的完整性验证
  - 多次回滚操作的稳定性

## 4. 数据质量验证

### 5.1 内容完整性
- **字符编码**: UTF-8、特殊字符的正确处理
- **文件完整性**: 操作前后的校验和验证

### 5.2 操作顺序验证
- **执行顺序**: 验证操作按照设计的优先级执行
- **依赖关系**: 确保依赖操作的正确顺序
- **原子性**: 验证批量操作的原子性特征

## 5. 错误消息测试

### 6.1 用户友好性
- **清晰的错误描述**: 错误消息应明确指出问题所在
- **可操作的建议**: 提供解决问题的具体建议
- **错误定位**: 精确指出出错的操作和位置

### 6.2 调试信息
- **详细日志**: 不同日志级别的输出验证
- **状态追踪**: 操作执行过程的状态记录
- **失败分析**: 失败原因的详细分析

## 6. 验收标准

### 6.1 功能完整性
- [ ] 所有定义的测试场景都能正确执行
- [ ] 错误情况得到适当处理

### 6.2 质量标准
- [ ] 测试覆盖率达到90%以上
- [ ] 所有边缘情况都有对应测试
- [ ] 错误消息清晰且有用

### 6.3 文档完整性
- [ ] 每个测试用例都有详细注释
- [ ] 测试结果有明确的成功/失败标准
- [ ] 提供故障排除指南

## 7. 测试实施计划

本测试需求将通过以下测试文件实现：
- `12_test_llm_scenarios.sh`: 基础LLM使用场景
- `13_test_llm_code_refactoring.sh`: 代码重构场景
- `14_test_llm_multi_file_edits.sh`: 多文件编辑场景
- `15_test_llm_error_recovery.sh`: 错误恢复与边缘情况

每个测试文件将包含详细的测试用例，遵循现有的测试框架结构，确保与其他测试的一致性和兼容性。
